<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>G116-D2</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { background-color: #0a0; color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { padding: 8px 12px; border: 1px solid #444; text-align: center; }
    .profitable { background-color: #00ff00; color: black; font-weight: bold; }
    #log { max-height: 220px; overflow-y: auto; border: 1px solid #444; margin-top: 10px; padding: 10px; background: #111; }
    button { padding: 8px 16px; margin: 5px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #555; }
    .control-group { margin: 10px 0; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; }
    .control-group label { display: flex; align-items: center; gap: 6px; }
    .profit-display { font-size: 1.1em; font-weight: bold; margin: 10px 0; padding: 8px; background: #333; border-radius: 4px; }
    .subtle { opacity: .9; font-weight: 600; }
    input[type="number"] { width: 90px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>G116-D2</h1>
  <p><strong>Wallet:</strong> <span id="wallet" class="mono">-</span></p>
  <p><strong>Wallet USDC Balance:</strong> <span id="walletBalance" class="mono">-</span></p>
  <p><strong>Contract USDC Balance:</strong> <span id="contractBalance" class="mono">-</span></p>
  <div class="profit-display">
    <strong>Accumulated Profit:</strong> <span id="accumulatedProfit" class="mono">0.00</span> USDC
  </div>

  <div class="control-group">
    <button id="connectWallet">Connect Wallet</button>
    <button id="scanNow">Scan Now</button>
    <button id="withdrawUSDC">Withdraw USDC</button>
    <button id="startScan">Start</button>
    <button id="stopScan">Stop</button>
    <button id="pauseScan">Pause</button>
  </div>

  <div class="control-group">
    <label><input type="checkbox" id="autoTradeToggle"> Auto Trade</label>
    <label><input type="checkbox" id="backgroundTradeToggle"> Auto Trade in Background</label>
    <label><input type="checkbox" id="accumulateToggle"> Let profits accumulate in contract</label>
    <label><input type="checkbox" id="positiveBalanceToggle" checked> Only trade if contract balance increases</label>
  </div>

  <div class="control-group">
    <label>Min Profit %: <input type="number" id="minProfitPct" value="0.2" step="0.1" min="0.1">%</label>
    <label>Trade Amount: <input type="number" id="tradeAmount" value="10" min="1"> USDC</label>
    <label>Batch Trades (1-100): <input type="number" id="batchCount" value="1" min="1" max="100" step="1"></label>
    <label>Slippage %: <input type="number" id="slippagePct" value="0" step="0.1" min="0">%</label>
  </div>

  <div class="control-group">
    <label>
      Scan interval:
      <input type="range" id="scanIntervalSec" min="0" max="100" value="30" step="1">
      <span id="scanIntervalLabel" class="subtle mono">30s</span>
    </label>
    <label title="If ON: we still show raw üö® opportunities, but add ‚úÖ when callStatic also shows profit. Auto-Trade will require ‚úÖ.">
      <input type="checkbox" id="callStaticToggle" checked>
      Require callStatic confirmation for Auto-Trade <span class="mono">‚úÖ</span>
    </label>
  </div>

  <table id="resultTable">
    <thead>
      <tr>
        <th>Token</th>
        <th>Buy Router</th>
        <th>Sell Router</th>
        <th>Buy Price (USDC)</th>
        <th>Sell Price (USDC)</th>
        <th>Profit (USDC)</th>
        <th>Profit %</th>
        <th>Status</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody id="results"></tbody>
  </table>

  <div id="log"></div>

  <div class="control-group">
    <button id="exportCSV">Export Successful Transactions</button>
  </div>

  <script>
    // -------------------------
    // CONFIG
    // -------------------------
    let transactionHistory = [];
    const contractAddress = "0x7ce1cd4584ceCBb94486c4C74071CBAAAB30c0dD";
    const contractABI = [{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"premium","type":"uint256"},{"internalType":"address","name":"initiator","type":"address"},{"internalType":"bytes","name":"params","type":"bytes"}],"name":"executeOperation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

    const tokens = {
      USDC:{address:"0x2791bca1f2de4661ed88a30c99a7a9449aa84174",decimals:6},
      USDT:{address:"0xc2132d05d31c914a87c6611c10748aeb04b58e8f",decimals:6},
      WBTC:{address:"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",decimals:8},
      // ... (all other tokens as before)
    };

    const routers = {
      QuickSwap: "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",
      SushiSwap: "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506",
      Dfyn: "0xA8b607Aa09B6A2641cF6F90f643E76d3f6e6Ff73",
      ApeSwap: "0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607"
    };

    let provider, signer, contract, walletAddress;
    let isScanning = false;
    let scanInterval;
    let accumulatedProfit = 0;

    // -------------------------
    // INIT
    // -------------------------
    window.addEventListener('load', function() {
      document.getElementById('connectWallet').addEventListener('click', connectWallet);
      document.getElementById('scanNow').addEventListener('click', async () => {
        if(isScanning){ log("Scan already in progress"); return; }
        await scanAndArbitrage();
      });
      document.getElementById('withdrawUSDC').addEventListener('click', withdrawUSDC);
      document.getElementById('scanIntervalSec').addEventListener('input', onScanIntervalChange);
      document.getElementById('callStaticToggle').addEventListener('change', ()=>{});
      restoreTransactionHistory();
      onScanIntervalChange();
    });

    async function connectWallet() {
      try {
        if (!window.ethereum) throw new Error("MetaMask not found");
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        walletAddress = await signer.getAddress();
        document.getElementById("wallet").textContent = walletAddress;
        contract = new ethers.Contract(contractAddress, contractABI, signer);
        await updateBalances();
        startAutoScan();
        log("Wallet connected successfully");
      } catch (e) { log(`‚ö†Ô∏è Wallet connection failed: ${e.message}`); }
    }

    function fmt(num, maxFrac=6){ if(!isFinite(num)) return "-"; if(Math.abs(num)<1e-6&&num!==0) return num.toExponential(2); return Number(num).toLocaleString(undefined,{maximumFractionDigits:maxFrac}); }

    async function updateBalances() {
      try {
        if(!provider||!walletAddress) return;
        const usdc = new ethers.Contract(tokens.USDC.address, ["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)"], provider);
        const decimals = await usdc.decimals();
        const [balance, contractBal] = await Promise.all([usdc.balanceOf(walletAddress), usdc.balanceOf(contractAddress)]);
        document.getElementById("walletBalance").textContent = fmt(ethers.utils.formatUnits(balance,decimals),6);
        document.getElementById("contractBalance").textContent = fmt(ethers.utils.formatUnits(contractBal,decimals),6);
      } catch(e){ log(`‚ö†Ô∏è Balance update failed: ${e.message}`); }
    }

    // -------------------------
    // SCAN / ARBITRAGE
    // -------------------------
    function currentIntervalMs(){ return Math.max(0,Math.min(100,parseInt(document.getElementById('scanIntervalSec').value||"30",10)))*1000; }

    function onScanIntervalChange(){
      const sec = parseInt(document.getElementById('scanIntervalSec').value||"30",10);
      document.getElementById('scanIntervalLabel').textContent=`${sec}s`;
      if(scanInterval){ startAutoScan(); }
    }

    function startAutoScan(){
      if(scanInterval) clearInterval(scanInterval);
      const iv = currentIntervalMs();
      if(iv===0){ scanInterval=setInterval(()=>{ if(!isScanning) scanAndArbitrage(); },250); }
      else{ scanInterval=setInterval(()=>{ if(!isScanning) scanAndArbitrage(); },iv); }
      log(`Auto scan interval set to ${fmt(iv/1000,0)}s`);
    }

    async function scanAndArbitrage(){
      if(!walletAddress){ log("Please connect your wallet first"); return; }
      isScanning=true;
      document.getElementById("results").innerHTML="";
      log("Starting arbitrage scan...");
      try{
        const minProfitPct=parseFloat(document.getElementById("minProfitPct").value);
        const tradeAmount=parseFloat(document.getElementById("tradeAmount").value);
        const slippagePct=parseFloat(document.getElementById("slippagePct").value);
        const requireStatic=document.getElementById("callStaticToggle").checked;
        const amountIn=ethers.utils.parseUnits(tradeAmount.toString(),6);

        for(const [symbol,meta] of Object.entries(tokens)){
          const token=meta.address;
          for(const [buyName,buyRouter] of Object.entries(routers)){
            for(const [sellName,sellRouter] of Object.entries(routers)){
              if(buyName===sellName) continue;
              try{
                const buyOut=await getAmountOut(buyRouter,token,amountIn);
                const sellOut=await getAmountOut(sellRouter,token,amountIn);
                const buyPrice=tradeAmount/buyOut;
                const sellPrice=tradeAmount/sellOut;
                const profitUSDC=sellPrice-buyPrice;
                const profitPct=(profitUSDC/buyPrice)*100;

                let profitPctStatic=NaN;
                if(requireStatic){
                  const buyOutStatic=await getAmountOut(buyRouter,token,amountIn);
                  const sellOutStatic=await getAmountOut(sellRouter,token,amountIn);
                  profitPctStatic=((sellPrice-buyPrice)/buyPrice)*100;
                }

                const slAdj=(1-(slippagePct/100));
                const slippageAdjustedProfitPct=profitPct*slAdj;
                const slippageAdjustedProfitUSDC=profitUSDC*slAdj;

                const row=document.createElement("tr");
                if(slippageAdjustedProfitPct>minProfitPct) row.classList.add("profitable");

                const getProfitable=slippageAdjustedProfitPct>minProfitPct;
                const staticProfitable=requireStatic ? (profitPctStatic>minProfitPct) : false;
                let statusSymbols='';
                if(getProfitable) statusSymbols+='üö®';
                if(requireStatic&&staticProfitable) statusSymbols+='‚úÖ';
                if(!statusSymbols) statusSymbols='‚ùå Skip';

                const actionCell=document.createElement("td");
                if(getProfitable){
                  const canAutoTradeNow=!requireStatic||(requireStatic&&staticProfitable);
                  const tradeBtn=document.createElement("button");
                  tradeBtn.textContent="Trade";
                  tradeBtn.onclick=()=>executeTrade(buyRouter,sellRouter,token,amountIn,symbol,slippageAdjustedProfitPct);
                  actionCell.appendChild(tradeBtn);

                  if(document.getElementById("autoTradeToggle").checked&&canAutoTradeNow){
                    const backgroundMode=document.getElementById("backgroundTradeToggle").checked;
                    if(backgroundMode){
                      executeTrade(buyRouter,sellRouter,token,amountIn,symbol,slippageAdjustedProfitPct).catch(e=>log(`‚ö†Ô∏è Background trade failed for ${symbol}: ${e.message}`));
                    } else { await executeTrade(buyRouter,sellRouter,token,amountIn,symbol,slippageAdjustedProfitPct); }
                  }
                }

                row.innerHTML=`
                  <td>${symbol}</td>
                  <td>${buyName}</td>
                  <td>${sellName}</td>
                  <td class="mono">${fmt(buyPrice,6)}</td>
                  <td class="mono">${fmt(sellPrice,6)}</td>
                  <td class="mono">${fmt(slippageAdjustedProfitUSDC,6)}</td>
                  <td class="mono">${fmt(slippageAdjustedProfitPct,2)}%</td>
                  <td>${statusSymbols}</td>
                `;
                row.appendChild(actionCell);
                document.getElementById("results").appendChild(row);

              } catch(e){ log(`‚ö†Ô∏è ${symbol} ${buyName}->${sellName} skipped: ${e.message}`); }
            }
          }
        }
      } catch(error){ log(`‚ö†Ô∏è Scan failed: ${error.message}`); }
      finally{ isScanning=false; await updateBalances(); log("Scan completed"); }
    }

    async function executeTrade(buyRouter,sellRouter,token,amountIn,symbol,profitPct){
      try{
        const batchCount=Math.min(parseInt(document.getElementById("batchCount").value||"1"),100);
        log(`‚ö° Executing arbitrage for ${symbol} (${profitPct.toFixed(2)}%) x${batchCount}...`);
        for(let i=0;i<batchCount;i++){
          const contractUSDCBefore=await getContractUSDCBalance();
          const params=ethers.utils.defaultAbiCoder.encode(["address","address","address","uint256"],[buyRouter,sellRouter,token,amountIn]);
          const tx=await contract.executeOperation(tokens.USDC.address,amountIn,0,walletAddress,params,{gasLimit:1000000});
          log(`Transaction ${i+1}/${batchCount} sent: ${tx.hash}`);
          const receipt=await tx.wait();
          const contractUSDCAfter=await getContractUSDCBalance();
          const profit=contractUSDCAfter-contractUSDCBefore;
          if(!document.getElementById("positiveBalanceToggle").checked||profit>0){ if(profit>0){ accumulatedProfit+=profit; document.getElementById("accumulatedProfit").textContent=Number(accumulatedProfit).toFixed(2); } }
          logTransaction({timestamp:Date.now(),txHash:receipt.transactionHash,symbol,profitBeforeFees:profitPct.toFixed(2)+'%',actualProfit:profit.toFixed(6)+' USDC',contractBalanceAfter:contractUSDCAfter.toFixed(6)+' USDC',buyDex:Object.keys(routers).find(k=>routers[k]===buyRouter)||buyRouter,sellDex:Object.keys(routers).find(k=>routers[k]===sellRouter)||sellRouter});
          log(`‚úÖ Arbitrage ${i+1}/${batchCount} done! Profit: ${profit.toFixed(6)} USDC`);
        }
        if(!document.getElementById("accumulateToggle").checked){
          const withdrawTx=await contract.withdrawProfits(); await withdrawTx.wait();
          log("üí∞ Profits withdrawn to your wallet");
        }
        await updateBalances();
      } catch(e){ log(`‚ö†Ô∏è Arbitrage failed for ${symbol}: ${e.message}`); throw e; }
    }

    async function withdrawUSDC(){
      try{ log("Withdrawing USDC from contract..."); const tx=await contract.withdrawProfits(); await tx.wait(); log("‚úÖ USDC withdrawn successfully"); updateBalances(); }
      catch(e){ log(`‚ö†Ô∏è Withdrawal failed: ${e.message}`); }
    }

    async function getContractUSDCBalance(){
      const usdc=new ethers.Contract(tokens.USDC.address,["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)"],provider);
      const decimals=await usdc.decimals();
      const bal=await usdc.balanceOf(contractAddress);
      return parseFloat(ethers.utils.formatUnits(bal,decimals));
    }

    async function getAmountOut(routerAddr, tokenAddr, amountIn){
      try{
        const router=new ethers.Contract(routerAddr, ["function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory)"], provider);
        const path=[tokens.USDC.address, tokenAddr];
        const amounts=await router.getAmountsOut(amountIn, path);
        return parseFloat(ethers.utils.formatUnits(amounts[amounts.length-1], tokens[tokenAddr]?.decimals || 18));
      } catch(e){ throw new Error(`getAmountOut failed: ${e.message}`); }
    }

    function log(msg){ const logEl=document.getElementById("log"); const now=new Date().toLocaleTimeString(); logEl.innerHTML=`[${now}] ${msg}<br>`+logEl.innerHTML; }

    function logTransaction(entry){ transactionHistory.push(entry); localStorage.setItem("txHistory",JSON.stringify(transactionHistory)); }

    function restoreTransactionHistory(){ try{ transactionHistory=JSON.parse(localStorage.getItem("txHistory")||"[]"); } catch(e){ transactionHistory=[]; } }

    document.getElementById("exportCSV").addEventListener("click",()=>{
      if(!transactionHistory.length){ log("‚ö†Ô∏è No successful transactions to export"); return; }
      const keys=Object.keys(transactionHistory[0]);
      const csv=[keys.join(",")].concat(transactionHistory.map(r=>keys.map(k=>r[k]).join(","))).join("\n");
      const blob=new Blob([csv],{type:"text/csv"});
      const url=URL.createObjectURL(blob);
      const a=document.createElement("a"); a.href=url; a.download="transactions.csv"; a.click(); URL.revokeObjectURL(url);
      log("‚úÖ Transaction history exported as CSV");
    });
  </script>
</body>
</html>

